### 1.2.1 数据类型



数据类型在计算机语言里面，是对内存位置的一个抽象表达方式，可以理解为针对内存的一种抽象的表达方式。接触每种语言的时候，都会存在数据类型的认识，有复杂的、简单的。各种数据类型都需要在学习初期去了解， Java 是强类型语言，所以 Java 对于数据类型的规范相对严格， 第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。

数据类型是语言的抽象原子概念，可以说是语言中最基本的单元定义，在 Java 里面，本质上数据类型分为两种：简单类型和复杂类型。

**简单类型：** 也称为原生数据类型， 简单数据类型是不能简化的、内置的数据类型、由编程语言本身定义，它表示了真实的数字、字符和整数。

**复杂类型：** 也称为构造数据类型， Java 语言本身不支持 C++中的指针、结构体（ struct）或联合体（ union）数据类型，它的复合数据类型一般都是通过类或接口进行构造，类提供了捆绑数据和方法的方式，同时可以针对程序外部进行信息隐藏。

Java 中的简单类型从概念上分为四种：** 实数（小数） 、整数 、字符 、布尔值**。但是有一点需要说明的是， Java 里面有八种原始类型， 如下：

实数： double（ 64bit） 、 float（ 32bit）

整数： byte（ 8bit） 、 short（ 16bit） 、 int（ 32bit） 、 long（ 64bit）

字符： char（ 16bit）

布尔值： boolean（ 1bit）

**a\)存储模型**

复杂类型和基本类型的内存模型本质上不一样，简单数据类型的存储

原理：所有的简单数据类型不存在“**引用** ”概 念，简单数据类型直接存储在内存中的内存栈上，数据本身的值存储在栈空间里面，而 Java 语言里面只有这八种数据类型是这种存储模型；而其他的只要是继承于 Object 类的复杂数据类型都是按照 Java 里面存储对象的内存模型来进行数据存储的，使用 Java 内存堆和内存栈来进行这种类型的数据存储，简单地讲， “引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的。

关于 JAVA 的内存模型，简介如下： （详细分析见第三章）

*  寄存器：我们在程序中无法控制
* 栈（ Stack）：存放基本类型的数据和对象的引用，但对象本身不存  放在栈中，而是存放在堆中
* 堆（ Heap）：存放用 new 产生的数据引用类型本身
* 静态域：存放在对象中用 static 定义的静态成员\
* 常量池：存放常量
* 非 RAM 存储：硬盘等永久存储空间

**b\)详细介绍**

int： int 为整数类型，在存储的时候，用 4 个字节存储，范围为2,147,483,648 到 2,147,483,647，在变量初始化的时候， int 类型的默认值为 0。

short： short 也属于整数类型，在存储的时候，用 2 个字节存储，范围为-32,768 到 32,767，在变量初始化的时候， short 类型的默认值为 0，一般情况下，因为 Java 本身转型的原因，可以直接写为 0。

long： long 也属于整数类型，在存储的时候，用 8 个字节存储，范围为-9,223,372,036,854,775,808 到 9,223,372,036, 854,775,807，在变量初始化的时候， long 类型的默认值为 0L 或 0l，也可直接写为 0。

byte： byte 同样属于整数类型，在存储的时候，用 1 个字节来存储 ，范围为-128 到 127，在变量初始化的时候， byte 类型的默认值也为 0。

float： float 属于实数类型，在存储的时候，用 4 个字节来存储，范围为 32 位 IEEEE 754 单精度范围，在变量初始化的时候， float 的默认值为 0.0f 或 0.0F，在初始化的时候可以写 0.0。

double： double 同样属于实数类型，在存储的时候，用 8 个字节来存储，范围为 64 位 IEEE 754 双精度范围，在变量初始化的时候， double 的默认值为 0.0。

char： char 属于字符类型，在存储的时候用 2 个字节来存储，因为Java 本身的字符集不是用 ASCII 码来进行存储，是使用的 16 位 Unicode字符集，它的字符范围即是 Unicode 的字符范围，在变量初始 化的时候 ，char 类型的默认值为'u0000'。

boolean： boolean 属于布尔类型，在存储的时候不使用字节，仅仅使用 1 位来存储，范围仅仅为 0 和 1，其字面量为 true 和 false，而 boolean变量在初始化的时候变量的默认值为 false。

**c\)自动装箱与自动拆箱**

基本数据类型的自动装箱\(autoboxing\)、拆箱\(unboxing\)是自 J2SE 5 开始提供的功能。

**自动装箱**

一般我们要创建一个类的对象的时候，我们会这样：

Class a = new Class\(parameter\);

当我们创建一个 Integer 对象时，却可以这样：

Integer i = 100; \(注意：不是 int i = 100; \)

实际上，执行上面那句代码的时候，系统为我们执行了：

 Integer i = new

Integer\(100\); 

此即基本数据类型的自动装箱功能。

基本数据类型与对象的差别是基本数据类型不是对象，也就是使用 int、

double、 boolean 等定义的变量、常量，基本数据类型没有可调用的方 法，

如：

int t = 1； // t 没有可以调用的方法

Integer t =1； // t 有很多方法可让你调用。

当我们定义类时，使用如 Integer t = 1；此时，系统会为我们自动装箱，

相当于编译器自动为您作以下的语法编译： Integer i = new Integer\(100\)。

**自动拆箱**

自动拆箱\(unboxing\)，也就是将对象中的基本数据从对象中自动取出 。

如下可实现自动拆箱：

Integer i = 10; //装箱

int t = i; //自动拆箱

在进行运算时，也可以进行自动装箱与拆箱。 下边是一个原始类型和

包装类型的一个对应表 1-2 如下：

表 1-2 原始类型与包装类型





int0 

byte 0 1 个字节 

char 的字符范围

long java.lang.Long 0L 或 0l 8 个字节 -2^63 到 2^63-1

float java.lang.Float 0.0F 或

0.0f

4 个字节 32 位 IEEEE 754 单精度

范围

| 原始类型 | 对应的包装类型 | 默认值 | 存储格式 | 数据范围 |
| :---: | :---: | :---: | :---: | :---: |
| short | java.lang.Short | 0 | 2 个字节 | -2^7 到 2^7-1 |
| int | java.lang.Integer | 0 | 4 个字节 | -2^31 到 2^31-1 |
| byte | java.lang.Byte | 0 | 1个字节 | -128 到 127 |
| char | java.lang.Character | \u0000 | 2 个字节 | Unicode 的字符范围 |
| long | java.lang.Long | 0L 或 0l | 8 个字节 | -2^63 到 2^63-1 |
| float | java.lang.Float | 0.0f或0.0F | 4个字节 | 32 位 IEEEE 754 单精度范围 |
| double | java.lang.Double  | 0.0或0.0D（d） | 8个字节 | 64位 IEEEE 754 单精度范围 |
| boolean | java.lang.Boolean | false | 1个字节 | true（1）或者false\(0\) |

**自动装箱、拆箱示例**

Integer 的自动装箱

//在-128~127 之外的数                                                                // 在-128~127 之内的数

Integer i1 = 200;                                                                                  Integer i3 = 100;

Integer i2 = 200;                                                                                  Integer i4 = 100;

System.out.println\("i1==i2: "+\(i1==i2\)\);                                          System.out.println\("i3==i4: "+\(i3==i4\)\);



输出的结果是：

i1==i2: false                                                                               i3==i4: true

**说明：** equals\(\) 比较的是两个对象的值（内容）是否相同。 "==" 比较的是两个对象的引用（内存地址） 是否相同，也用来比较两个基本数据类型的变量值是否相等。

在自动装箱时对于值从-128 到 127 之间的值，它们被装箱为 Integer对象后，会存在内存中被重用，也就是封装到同一个对象当中，实际上是放在常量池中。所以范例中， i3 与 i4 实际上参考至同一个对象。如果超

过了从-128 到 127 之间的值，被装箱后的 Integer 对象并不会被重用，即相当于每次装箱时都新建一个 Integer 对象，其值放在 JVM 堆中，其引用存放在 JVM 栈中，所以范例中， i1 与 i2 参考的是不同的对象。另外，当不使用自动装箱功能的时候，情况与普通类对象一样。

同样,见 String 的拆箱装箱如下：

String str1 = "abc"; // 存放在常量

池中

String str2 = "abc"; // 存放在常量

池中

System.out.println\(str2==str1\); //输出 true

System.out.println\(str2.equals\(str1\)\); //输

出为 true

String str3 = new String\("abc "\); //新对

象

String str4 = new String\("abc "\); //新对

象

System.out.println\(str3==str4\); //输出 false

System.out.println\(str3.equals\(str4\)\); //

输出 true



**d\)类型转换**

JAVA 中只有 boolean 不参与数据类型的转换，其他的类型转换大致分为两类：自动类型转换，强制类型转换。

1\) 自动类型的转换

a. 常数在表数范围内是能够自动类型转换的。

b. 数据范围小的能够自动转换为范围大的数据类型，但是 int 到float， long 到 float， long 到 double 是不会自动转换的，否则会丢失精度。

c. 引用类型能够自动转换为父类的。

d. 基本类型和它们包装类型是能够互相转换的。

2\) 强制类型转换，用圆括号括起来目标类型，置于变量前。

如 int x = 1； Integer xx =（ Integer） x;

a. 转换的源数据类型和目标数据类型要兼容。

b. 浮点类型变量强制转换为整型时，直接将小数位舍去。

c. 高级别数据类型强制转换为低级别的数据类型时，数据可能会溢出或者精确度下降。



