### **3.2.1 JVM内存划分详解**

* #### 堆中的内存分配
* #### 方法区中的内存分配
* #### 程序计数器\(PC指针\)
* #### JVM栈的内存分配
* #### 本地方法栈\(NATIVE METHOD STACKS\)
* #### 运行时常量池\(RUNTIME CONSTANT POOL\)
* #### 本地直接内存\(DIRECT MEMORY\)

直接内存并不是虚拟机运行时数据区的一部分，它根本就是本机内存 而不是 JVM 直接管理的区域。但是这部分内存也会导致 OutOfMemoryError 异常出现，因此我们放到这里一起描述。 

在 JDK1.4 中新加入了 NIO 类，引入一种基于渠道与缓冲区的 I/O 方 式，它可以通过本机 Native 函数库直接分配本机内存，然后通过一个存储 在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这 样能在一些场景中显著提高性能，因为避免了在 Java 对和本机堆中来回复 制数据。 

显然本机直接内存的分配不会受到 Java 堆大小的限制，但是即然是内 存那肯定还是要受到本机物理内存（包括 SWAP 区或者 Windows 虚拟内存） 的限制的，一般服务器管理员配置 JVM 参数时，会根据实际内存设置-Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内 存限制（包括物理的和操作系统级的限制），而导致动态扩展时出现 OutOfMemoryError 异常。

DirectMemory 容量可通过-XX:MaxDirectMemorySize 指定，不指定的 话默认与 Java 堆（-Xmx 指定）一样。 

到此为止，我们弄清楚虚拟机里面的内存是如何划分的，哪部分区域， 什么样的代码、操作可能导致 OOM（out of memory）异常。虽然 Java 有 垃圾收集机制，但 OOM 仍然离我们并不遥远，

#### 



