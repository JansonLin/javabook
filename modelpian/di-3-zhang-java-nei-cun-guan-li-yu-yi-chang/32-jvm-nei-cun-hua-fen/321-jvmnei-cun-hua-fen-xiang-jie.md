### **3.2.1 JVM内存划分详解**

* #### 堆中的内存分配

对于绝大多数应用来说，Java 堆是虚拟机管理最大的一块内存。Java 堆是被所有线程共享的，在虚拟机启动时创建。Java 堆的唯一目的就是存 放对象实例，绝大部分的对象实例都在这里分配。 

官方文档中，JVM 堆划分为： 

* 新域：存放所有新生成的对象。 
* 旧域：新域中的对象，经过 GC（垃圾回收）循环后，进入旧域 。 
* 永久域：存储类和方法对象。从配置的角度看，这个域是独立的， 默认大小为4m，不包括在 JVM堆内，我们将其称为方法区。

更细致一点，JVM堆可以被划分为：eden、from survivor、to survivor，甚至更细粒度的本地线程分配缓冲（TLAB）等，无论对 Java堆如何划分， 目的都是为了更好的回收内存，或者更快的分配内存，这里不作多解释， 防止读者混淆，有兴趣的读者可以查阅 JVM调优相关资料。 

JVM堆可以处于物理上不连续的内存空间，它逻辑上是连续的即可， 就像我们的磁盘空间一样。实现时可以选择实现成固定大小的，也可以是可扩展的，不过当前所有商业的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中无法分配内存，并且堆也无法再扩展时， 将会抛出OutOfMemoryError异常。 

配置 JVM 参数有两种方法，我们可以在系统环境变量中设置新的变量： JAVA\_OPTS或者在控制台执行java命令，如下是把堆初始大小设置为 128m，最大值设置为 512m： 

在控制台执行： java -Xms128m –Xmx512m 

配置：JAVA\_OPTS = -Xms128m –Xmx512m 

如果要控制新域的大小，可使用-XX:NewRatio 设置新域在堆中所占的比例，下面的命令把整个堆设置成128m，新域比率设置成 3，即新域与旧 域比例为 1：3，新域为堆的 1/4。当然也可以用配置环境变量的方法。

* #### 方法区中的内存分配

Java虚拟机会将加载的java类存入方法区，方法区中存放了每个Class的结构信息，包括常量池、字段描述、方法描述等，方法区可以被所有线程共享，其包含的内容是整程序中永远唯一的元素，所以在JVM中的存储区域称为永久域。 

方法区大小可以是固定的，也可以是动态扩展或收缩的。如果是固定大小的，我们可以设置大小。如果是动态变化的，我们可以设置最大和最小值，同样，可以是不连续的。编写中小型程序时，一般不会造成方法区的内存溢出。 

当 jvm 加载类时，永久域中的对象急剧增加，从而使 jvm 不断调整永 久域大小。为了避免调整，可使用-XX:PerSize 标志设置初始值，-XX： MaxPermSize 设置最大值。下面是把永久域初始值设置成 32m，最大值设 置成 64m。

Java -XX:PermSize=32m -XX:MaxPermSize=64m 

JAVA\_OPTS = -XX:PermSize=32m -XX:MaxPermSize=64m

* #### 程序计数器\(PC指针\)

每一个 Java 线程都有一个程序计数器来用于保存程序执行到当前方法的哪一个指令，对于非Native方法，这个区域记录的是正在执行的VM原语的地址，如果正在执行的是Natvie方法（如JNI调用，非JAVA程序）， 这个区域则为空（undefined）。此内存区域是唯一一个不会产生OutOfMemoryError情况的区域。

* #### JVM栈的内存分配

与程序计数器一样，VM栈的生命周期也是与线程相同。VM栈描述的是 Java 方法调用的内存模型：每个方法被执行的时候，都会同时创建一个帧（Frame）用于存储本地变量表、操作栈、动态链接、方法出入口等信息。每一个方法的调用至完成，就意味着一个帧在VM栈中的入栈至出栈的过程。 

经常有人把Java内存简单的区分为堆内存（Heap）和栈内存（Stack），实际中的区域远比这种观点复杂，这样划分只是说明与变量定义密切相关 的内存区域是这两块。“栈”就是 VM 栈中各个帧的本地变量表部分。本地 变量表存放了编译期可知的各种标量类型（boolean、byte、char、short、int、 float、long、double）、对象引用（不是对象本身，仅仅是一个引用指针）、方法返回地址等。其中 long和double会占用 2个本地变量空间（32bit）， 其余占用1个。本地变量表在进入方法时进行分配，当进入一个方法时， 这个方法需要在帧中分配多大的本地变量是一件完全确定的事情，在方法运行期间不改变本地变量表的大小。 

JVM 栈会出现两种异常状况：如果线程请求的栈深度大于虚拟机所允 许的深度，将抛出 StackOverflowError 异常；如果 JVM 栈可以动态扩 展， 当扩展时无法申请到足够内存则抛出 OutOfMemoryError 异常。 

JVM中栈的参数设置是由-Xss参数设定，如java–Xss512k

* #### 本地方法栈\(NATIVE METHOD STACKS\)

本地方法栈与JVM栈所发挥作用是类似的，只不过JVM栈为虚拟机运行JVM原语服务，而本地方法栈是为虚拟机使用到的Native方法服务。 它的实现的语言、方式与结构并没有强制规定，甚至有的虚拟机（譬如Sun Hotspot虚拟机）直接就把本地方法栈和JVM 栈合二为一。和JVM栈一样， 这个区域也会抛出StackOverflowError和OutOfMemoryError异常。

* #### 运行时常量池\(RUNTIME CONSTANT POOL\)

Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量表\(constant\_pool table\)，用于存放编译期已可知的常量， 这部分内容将在类加载后进入方法区（永久代）存放。但是 Java 语言并不要求常量一定只有编译期预置入Class的常量表的内容才能进入方法区常量池，运行期间也可将新内容放入常量池（最典型的 String.intern\(\)方法）。 运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常。 

由于常量池分配在方法区内，我们只需要通过-XX:PermSize和-XX:MaxPermSize限制方法区大小即可限制常量池容量

* #### 本地直接内存\(DIRECT MEMORY\)

直接内存并不是虚拟机运行时数据区的一部分，它根本就是本机内存 而不是 JVM 直接管理的区域。但是这部分内存也会导致 OutOfMemoryError 异常出现，因此我们放到这里一起描述。

在JDK1.4中新加入了NIO类，引入一种基于渠道与缓冲区的I/O方 式，它可以通过本机Native函数库直接分配本机内存，然后通过一个存储 在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这 样能在一些场景中显著提高性能，因为避免了在 Java 对和本机堆中来回复 制数据。

显然本机直接内存的分配不会受到 Java 堆大小的限制，但是即然是内 存那肯定还是要受到本机物理内存（包括SWAP区或者 Windows虚拟内存）的限制的，一般服务器管理员配置 JVM 参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），而导致动态扩展时出现OutOfMemoryError异常。

DirectMemory容量可通过-XX:MaxDirectMemorySize 指定，不指定的话默认与Java堆（-Xmx 指定）一样。

到此为止，我们弄清楚虚拟机里面的内存是如何划分的，哪部分区域， 什么样的代码、操作可能导致OOM（out of memory）异常。虽然Java有 垃圾收集机制，但OOM仍然离我们并不遥远，

#### 



